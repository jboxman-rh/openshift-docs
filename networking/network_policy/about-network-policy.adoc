[id="about-network-policy"]
= About network policy
include::modules/common-attributes.adoc[]
:context: about-network-policy

toc::[]

As a project administrator, you can define network policies that restrict traffic to or from pods in a namespace.

[NOTE]
====
Any network policies defined by a cluster administrator can be overwritten by a project administrator. Do not use network policies to define cluster-wide network traffic policy.
====

What follows is a discussion of how network traffic isolation works with network policy.

[id="network-policy-concepts_{context}"]
== Network policy concepts

You can use a network policy to allow and deny network traffic within a particular namespace. The following concepts apply to network policy:

* Network policy applies to pods in the namespace in which the policy is applied.
* Network policy defines two types of rules:
** Ingress rules that allow traffic to pods from other pods or IP address blocks.
** Egress rules that allow traffic from pods to other pods or IP address blocks.
* Network policy supports the TCP, UDP, and SCTP protocols.
* Network policy supports specifying ports for supported protocols.

// My original thought was that the pods in a namespace are one "part"
// and the rules are the other "part". And then a rule can be either for
// ingress or egress. But maybe that segmentation doesn't make sense?
A network policy consists of three parts:

* Pod selector: Identifies which pods the network policy isolates. A pod selected by a pod selector is considered to be an _isolated pod_.
* Ingress and egress rules: Identifies _network policy peers_. A peer is a pod selected by an ingress or egress rule selector.
* Policy types: Specifies whether the network policy includes ingress rules, egress rules, or both.

.Network policy object
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: policy-object-example
spec:
  podSelector: <.>
  ingress: [] <.>
  egress: [] <.>
  policyTypes: <.>
  - Ingress
  - Egress
----
<.> Pod selector.
<.> Optional: Ingress rules that define network policy peers in a particular namespace.
<.> Optional: Egress rules that define network policy peers in a particular namespace.
<.> Optional: Policy types defined by the network policy. If not specified, the default value is `Ingress`.

[id="policy-isolation-behavior_{context}"]
== Network policy pod isolation behavior

A pod that is isolated is one that is selected by the pod selector of at least one network policy.
If a pod is not selected by the pod selector of any network policy in the namespace that the pod exists, the pod is unaffected by network policy and all ingress and egress traffic is permitted.

If a namespace does have network policy rules defined then the following applies:

* If a pod is not selected by any ingress network policy rule selectors, then all ingress traffic is allowed to that pod
* If a pod is not selected by any egress network policy rule selectors, then all egress traffic is allowed from that pod

[IMPORTANT]
====
To ensure that pods in a particular namespace are isolated by default, it is recommended to always create a _deny ingress by default_ network policy that selects all pods in that namespace.
====

[id="requirements-for-network-policy_{context}"]
== Requirements for network policy

Your cluster must use a network provider that supports the use of network policy, such as OVN-Kubernetes or OpenShift SDN with network policy isolation mode configured.

[NOTE]
====
When using the OpenShift SDN cluster network provider, the following limitations apply regarding network policies:

* Egress network policy as specified by the `egress` field is not supported.
* IPBlock is supported by network policy, but without support for `except` clauses. If you create a policy with an IPBlock section that includes an `except` clause, the SDN pods log warnings and the entire IPBlock section of that policy is ignored.
====

By default, the following roles can create, edit, and delete a network policy:

* `cluster-admin`
* `admin`

// Duplicated here because this is really important for cluster admins to know.
[NOTE]
====
Any network policies defined by a cluster administrator can be overwritten by a project administrator. Do not use network policies to define cluster-wide network traffic policy.
====

[id="limitations-of-network-policy_{context}"]
== Limitations of network policy

The following limitations apply to the use of network policy:

* You cannot use DNS names with network policy.
* You cannot use network policy with host network to host network traffic.

Additionally, network policy has the following limitations when a host network pod is involved:
* When a pod network pod tries to connect to a host network pod, the traffic is affected by egress network policies that match the pod network pod, but the traffic is unaffected by ingress policies that match the host network pod.
* When a host network pod tries to connect to a pod network pod, the following behaviors apply:
** If there is an `allow-from-host-network` policy defined that matches the pod network pod, then the traffic is allowed.
** If the aforementioned policy is not defined, then the behavior is undefined. Even if a network policy blocks all ingress traffic to the pod network pod, it is possible a host network pod can connect to it. The behavior is not consistent across Container Network Interface (CNI) plug-ins.

[id="types-of-network-traffic-supported_{context}"]
== Network traffic protocols supported

You can use specify a network policy for only the TCP, UDP, and SCTP network protocols.

[id="types-of-network-policy-rules_{context}"]
== Types of network policy rules

Network policy supports the following policy rules:

* Ingress
* Egress

A network policy can contain both ingress and egress network policy rules.

Policy types are unidirectional. If you define both ingress and egress policies for your cluster, traffic must be allowed for both ingress and egress for network traffic between pods.

For example, if an ingress network policy rule allows a destination pod to receive traffic from a source pod, but the source pod is restricted from communicating with the destination pod with an egress network policy rule, the connection is blocked.

[NOTE]
====
If you are using the OpenShift SDN cluster network provider, only the ingress policy type is supported.
====

[id="policy-scope_{context}"]
== Network policy scope

A network policy is scoped to a specific namespace and can be further limited to a specific subset of pods in that namespace.

If multiple network policies are defined in a namespace they are applied additively, which means network policies can be created in any order.

[id="policy-isolation_{context}"]
== Network policy isolation of network traffic

A network policy can apply to the following network traffic flows:

* Traffic between pods in the same namespace
* Traffic between pods in different namespaces
* Traffic from an IP address block to a pod
* Traffic to an IP address block from a pod

[id="selectors_{context}"]
== Selectors

A network policy uses selectors in two ways:

* As an pod selector to select the pods that the policy isolates
* As a policy rule selector to select which traffic from a pod or to a pod to allow

[id="select-pods-that-a-policy-isolates_{context}"]
=== Selection of pods that a policy isolates

A pod selector identifies the set of pods that a network policy isolates. You can isolate all pods in a namespace or selectively apply a network policy to a subset of pods.

If you specify an empty `podSelector`, as in the following example, then all pods in a namespace are selected.

.Example network policy with an empty `podSelector` field
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: empty-pod-selector
spec:
  podSelector:
  ingress: []
  policyTypes:
  - Ingress
----

[id="select-pods-that-a-policy-rule-applies-to_{context}"]
=== Selection of pods that a policy rule applies to

When you specify a network policy rule, you use selectors to:

* Specify the namespaces that ingress and egress rules apply to
* Specify the pods in a selected namespace to apply to

The specific behavior for policy rule selectors is as follows:

* If only a namespace selector is used then a policy rule applies to all pods in that namespace.
* If only a pod selector is used then a policy rule applies to only the namespace in which the network policy is defined.
* If both a namespace selector and pod selector are used in a policy rule then only pods that satisfy both selectors are selected.

The following examples illustrate the rule selector behavior.

.Example network policy with a `namespaceSelector` field
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-namespace-selector
spec:
  podSelector:
  ingress:
  - namespaceSelector:
      matchLabels:
ifeval::[{product-version} < 4.8]
        networking-namespace: web
endif::[]
ifeval::[{product-version} >= 4.8]
        kubernetes.io/metadata.name: web
endif::[]
  policyTypes:
  - Ingress
----

.Example network policy with a `podSelector` field
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-pod-selector
spec:
  podSelector:
  ingress:
  - podSelector:
      matchLabels:
        deployment: blue
  policyTypes:
  - Ingress
----

.Example network policy with `namespaceSelector` and `podSelector` fields
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-combined-selector
spec:
  podSelector:
  ingress:
  - podSelector:
      matchLabels:
        deployment: blue
    namespaceSelector:
      matchLabels:
ifeval::[{product-version} < 4.8]
        namespace-name: web
endif::[]
ifeval::[{product-version} >= 4.8]
        kubernetes.io/metadata.name: web
endif::[]
  policyTypes:
  - Ingress
----

ifeval::[{product-version} < 4.8]
[NOTE]
====
A namespace does not have a label by default. To add a label to a namespace as a target for a namespace selector, add a label such as with the `oc label namespace <name> namespace-name=<name>` command. Replace `<name>` with the name of the namespace the label is applied to.
====
endif::[]
ifeval::[{product-version} >= 4.8]
[NOTE]
====
Beginning with {product-title} 4.8, which is based on Kubernetes 1.21, link:https://kubernetes.io/docs/reference/labels-annotations-taints/#kubernetes-io-metadata-name[the following label is added automatically to each namespace]:

[source,yaml]
----
metadata:
  name: <name>
  labels:
    kubernetes.io/metadata.name: <name>
----
====
endif::[]

// Labels that a selector can target, not a selector itself.
[id="available-selector-policy-groups_{context}"]
=== Available labels for existing policy groups

Several custom labels are available in {product-title}:

`policy-group.network.openshift.io/ingress: ""`::
+
--
Selects all Ingress Controller router pods.

While the deprecated label `network.openshift.io/policy-group: ingress` continues to work, its use is not recommended.

If you expose a service from a namespace where you have defined network policies, you can use this label to ensure that incoming traffic from the router pods is allowed. A service is typically exposed with the `oc expose service` command.

.Example network policy to allow ingress from router pods
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: web-allow-router
spec:
  podSelector:
    matchLabels:
      app: web
  ingress:
  - from:
    - namespaceSelector:
      policy-group.network.openshift.io/ingress: ""
    ports:
    - port: 4443
----

[NOTE]
====
If your `default` Ingress Controller runs on the host network, this namespace selector also allows all traffic for the host network. You can determine if your `default` Ingress Controller uses the `HostNetwork` endpoint publishing strategy with the following command:

[source,terminal]
----
$ oc get --namespace openshift-ingress-operator ingresscontrollers/default \
  --output jsonpath='{.status.endpointPublishingStrategy.type}'
----

If the previous command reports the endpoint publishing strategy as `HostNetwork`, then your `default` Ingress Controller is on the host network.
====
--

`policy-group.network.openshift.io/host-network`: ""::
Selects all host network traffic. You cannot combine this namespace selector with a pod selector.

[id="policy-rules_{context}"]
== Policy rules

A network policy must specify one or more policy rules that identifies what ingress or egress traffic is permitted for pods that the network policy isolates.

[id="policy-rule-logical-ordering_{context}"]
=== Logical ordering

In a single network policy one or more policy rules can be defined. The following logic applies when evaluating an array of one or more ingress or egress policy rules:

// This is completely wrong; remove
////
* If a policy rule includes both a namespace selector and a pod selector then a logical `and` is used when evaluating both.
* If multiple policy rules are defined then a logical `or` is used when evaluating each policy rule.
////

[id="policy-rule-precedence_{context}"]
=== Precedence

Any network policy rule that denies either ingress or egress traffic for a pod is always superseded by a policy rule that allows the denied traffic.

For example, consider the following network policies:

[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: web-deny-all
spec:
  podSelector:
    matchLabels:
      app: web
  ingress: []
---
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
metadata:
  name: web-allow-http
spec:
  podSelector:
    matchLabels:
      app: web
  ingress:
  - from:
    - podSelector: {}
    ports:
    - port: 8088
----



// This is wrong; delete
////
Because precedence indicates the rules that allow traffic always supersede rules that deny traffic, the effect of the two policies on the cluster is to allow ingress traffic only on port `8088` to the pod with the `app=web` label from any other pods in the same namespace. All other ingress traffic for the isolated pod is rejected.
////

[id="restrictions-by-ports-protocols_{context}"]
=== Restrictions by ports and protocols

You can restrict traffic by port and protocol. The following conditions apply:

- If you do not specify a port or a protocol, the policy rule applies to all traffic types on all ports
- If you specify a protocol but omit a port then the default is all ports
- If you specify a port but omit a protocol then the default protocol is TCP

[id="restrictions-by-ip_adress-blocks_{context}"]
=== Restrictions by IP address blocks

In addition to selectors for pods and namespaces, you can define a network policy rule that selects an IP address block specified in CIDR form. Optionally, you can exclude one or more subsets of the IP address block.

[NOTE]
====
If IP addresses are rewritten during packet handling, whether this happens before or after network policy processing is undefined. For more information, see link:https://kubernetes.io/docs/concepts/services-networking/network-policies/#behavior-of-ipblock-selectors[ipBlock].
====

// ipBlock is challenging to use because IP addresses can be rewritten.
// https://kubernetes.io/docs/concepts/services-networking/network-policies/#behavior-of-ipblock-selectors

.Example ingress rule that matches an IP address block
[source,yaml]
----
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
metadata:
  name: <name>
spec:
  egress:
  - to:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
        - 172.17.2.0/24
----

In the previous example, the network policy allows egress traffic to the `172.17.0.0/16` IP address block, except for traffic from the `172.17.1.0/24` and `172.17.2.0/24` IP address blocks.

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From:
      IPBlock:
        CIDR: 172.17.0.0/16
        Except: 172.17.1.0/24
  Not affecting egress traffic
  Policy Types: Ingress
////

[id="policy-rule-behavior-with-an-empty-selector_{context}"]
=== Behavior with an empty selector

If you specify an empty selector, the behavior of a network policy is as follows:

* For the pods selected by a network policy pod selector the policy applies to all pods in the namespace where the network policy is defined. For example, the following network policy allows all ingress traffic from port `443` to all pods in the namespace:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-all-https
spec:
  podSelector: {}
  ingress:
  - ports:
    - port: 443
----

* For the network policy peers selected by a network policy rule:
** If a network policy ingress or egress rule omits a namespace selector, the policy applies to all namespaces. For example:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-only-db-pods
spec:
  podSelector: {}
  ingress:
    from:
    - podSelector:
        matchLabels:
          app: db
      ports:
      - port: 5432
----
** If a network policy ingress or egress rule omits the pod selector, the policy applies to all pods in any selected namespace, or in all namespaces if no namespace selector is specified. For example:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-only-db-https-ns
spec:
  podSelector: {}
  ingress:
    from:
    - namespaceSelector:
        matchLabels:
          app: web
      ports:
      - port: 443
----

[id="policy-rule-behavior-with-an-empty-ingress-or-egress-rule-set_{context}"]
=== Behavior with an empty ingress or egress rule set

If you define a network policy rule with an empty list, the network policy does not allow any traffic.

For example, the following ingress rule allows no ingress traffic:

.Example ingress ruleset defined as an empty list
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: <name>
spec:
  ingress: []
----

////
Name:         name1
Namespace:    default
Created on:   2021-06-28 21:11:24 -0400 EDT
Labels:       <none>
Annotations:  <none>
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    <none> (Selected pods are isolated for ingress connectivity)
  Not affecting egress traffic
  Policy Types: Ingress
////

An empty rule set is the inverse of a rule set with a single empty selector, which selects and allows all traffic. For example, the following ingress rule set selects all ingress traffic:

.Example ingress ruleset with a single empty selector
[source,yaml]
----
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
spec:
  ingress:
  - {}
----

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From: <any> (traffic not restricted by source)
  Not affecting egress traffic
  Policy Types: Ingress
////

The previous example is identical in behavior to the following example:

.Example ingress ruleset that matches all ingress traffic
[source,yaml]
----
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
spec:
  ingress:
  - from:
    - podSelector: {}
      namespaceSelector: {}
----

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From:
      NamespaceSelector: <none>
      PodSelector: <none>
  Not affecting egress traffic
  Policy Types: Ingress
////

[id="network-policy-examples"]
== Network policy examples

The following example `NetworkPolicy` objects demonstrate supporting different scenarios:

* Deny all traffic:
+
To make a project deny by default, add a `NetworkPolicy` object that matches all pods but accepts no traffic:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-by-default
spec:
  podSelector:
  ingress: []
----

* Only allow connections from the {product-title} Ingress Controller:
+
To make a project allow only connections from the {product-title} Ingress Controller, add the following `NetworkPolicy` object.
+
[IMPORTANT]
====
For the OVN-Kubernetes network provider plug-in, when the Ingress Controller is configured to use the `HostNetwork` endpoint publishing strategy, there is no supported way to apply network policy so that ingress traffic is allowed and all other traffic is denied.
====
+
[source,yaml]
----
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-openshift-ingress
spec:
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          network.openshift.io/policy-group: ingress
  podSelector: {}
  policyTypes:
  - Ingress
----
+
If the Ingress Controller is configured with `endpointPublishingStrategy: HostNetwork`, then the Ingress Controller pod runs on the host network.
When running on the host network, the traffic from the Ingress Controller is assigned the `netid:0` Virtual Network ID (VNID).
The `netid` for the namespace that is associated with the Ingress Operator is different, so the `matchLabel` in the `allow-from-openshift-ingress` network policy does not match traffic from the `default` Ingress Controller.
With OpenShift SDN, the `default` namespace is assigned the `netid:0` VNID and you can allow traffic from the `default` Ingress Controller by labeling your `default` namespace with `network.openshift.io/policy-group: ingress`.

* Only accept connections from pods within a project:
+
To make pods accept connections from other pods in the same project, but reject all other connections from pods in other projects, add the following `NetworkPolicy` object:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-same-namespace
spec:
  podSelector:
  ingress:
  - from:
    - podSelector: {}
----

* Only allow HTTP and HTTPS traffic based on pod labels:
+
To enable only HTTP and HTTPS access to the pods with a specific label (`role=frontend` in following example), add a `NetworkPolicy` object similar to the following:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-http-and-https
spec:
  podSelector:
    matchLabels:
      role: frontend
  ingress:
  - ports:
    - protocol: TCP
      port: 80
    - protocol: TCP
      port: 443
----

* Accept connections by using both namespace and pod selectors:
+
To match network traffic by combining namespace and pod selectors, you can use a `NetworkPolicy` object similar to the following:
+
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-pod-and-namespace-both
spec:
  podSelector:
    matchLabels:
      name: test-pods
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            project: project_name
        podSelector:
          matchLabels:
            name: test-pods
----

`NetworkPolicy` objects are additive, which means you can combine multiple `NetworkPolicy` objects together to satisfy complex network requirements.

For example, for the `NetworkPolicy` objects defined in previous samples, you can define both `allow-same-namespace` and `allow-http-and-https` policies within the same project. Thus allowing the pods with the label `role=frontend`, to accept any connection allowed by each policy. That is, connections on any port from pods in the same namespace, and connections on ports `80` and `443` from pods in any namespace.

//include::modules/nw-networkpolicy-about.adoc[leveloffset=+1]
//include::modules/nw-networkpolicy-optimize.adoc[leveloffset=+1]

[id="about-network-policy-next-steps"]
== Next steps

* xref:../../networking/network_policy/creating-network-policy.adoc#creating-network-policy[Creating a network policy]
* Optional: xref:../../networking/network_policy/default-network-policy.adoc#default-network-policy[Defining a default network policy]

[id="about-network-policy-additional-resources"]
== Additional resources

* xref:../../networking/network_policy/multitenant-network-policy.adoc#multitenant-network-policy[Configuring multitenant network policy]
* xref:../../rest_api/network_apis/networkpolicy-networking-k8s-io-v1.adoc#networkpolicy-networking-k8s-io-v1[NetworkPolicy API]
