[id="about-network-policy"]
= About network policy
include::modules/common-attributes.adoc[]
:context: about-network-policy

toc::[]

As a project administrator, you can define network policies that restrict traffic to or from pods in a namespace.

// This probably needs further elaboration
// What permissions exactly govern this that it can be overwritten?
// Need to know more about OCP roles and authorization
[NOTE]
====
Any network policies defined by a cluster administrator can be overwritten by a project administrator. Do not use network policies to define cluster-wide network traffic policy.
====

What follows is a discussion of how network traffic isolation works with network policy.

[id="network-policy-concepts_{context}"]
== Network policy concepts

You can use a network policy to allow and deny network traffic within a particular namespace. The following concepts apply to network policy:

* Network policy applies to pods in the namespace in which the policy is applied.
* Network policy defines two types of rules:
** Ingress rules that allow traffic to pods from other pods or IP address blocks.
** Egress rules that allow traffic from pods to other pods or IP address blocks.
* Network policy supports the TCP, UDP, and SCTP protocols.
* Network policy supports specifying ports for supported protocols.

// My original thought was that the pods in a namespace are one "part"
// and the rules are the other "part". And then a rule can be either for
// ingress or egress. But maybe that segmentation doesn't make sense?
A network policy consists of three parts:

* Pod selector: Identifies which pods the network policy isolates. A pod selected by a pod selector is considered to be an _isolated pod_.
* Ingress and egress rules: Identifies _network policy peers_. A peer is a pod selected by an ingress or egress rule selector.
* Policy types: Specifies whether the network policy includes ingress rules, egress rules, or both.

.Network policy object
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: policy-object-example
spec:
  podSelector: <.>
  ingress: [] <.>
  egress: [] <.>
  policyTypes: <.>
  - Ingress
  - Egress
----
<.> Pod selector.
<.> Optional: Ingress rules that define network policy peers in a particular namespace.
<.> Optional: Egress rules that define network policy peers in a particular namespace.
<.> Optional: Policy types defined by the network policy. If not specified, the default value is `Ingress`.

[id="policy-isolation-behavior_{context}"]
== Network policy pod isolation behavior

A pod that is isolated is one that is selected by the pod selector of at least one network policy.
If a pod is not selected by the pod selector of any network policy in the namespace that the pod exists, the pod is unaffected by network policy and all ingress and egress traffic is permitted.

If a namespace does have network policy rules defined then the following applies:

* If a pod is not selected by any ingress network policy rule selectors, then all ingress traffic is allowed to that pod
* If a pod is not selected by any egress network policy rule selectors, then all egress traffic is allowed from that pod

[IMPORTANT]
====
To ensure that pods in a particular namespace are isolated by default, it is recommended to always create a _deny ingress by default_ network policy that selects all pods in that namespace.
====

[id="requirements-for-network-policy_{context}"]
== Requirements for network policy

Your cluster must use a network provider that supports the use of network policy, such as OVN-Kubernetes or OpenShift SDN with network policy isolation mode configured.

[NOTE]
====
When using the OpenShift SDN cluster network provider, the following limitations apply regarding network policies:

* Egress network policy as specified by the `egress` field is not supported.
* IPBlock is supported by network policy, but without support for `except` clauses. If you create a policy with an IPBlock section that includes an `except` clause, the SDN pods log warnings and the entire IPBlock section of that policy is ignored.
====

By default, the following roles can create, edit, and delete a network policy:

* `cluster-admin`
* `admin`

// Duplicated here because this is really important for cluster admins to know.
[NOTE]
====
Any network policies defined by a cluster administrator can be overwritten by a project administrator. Do not use network policies to define cluster-wide network traffic policy.
====

[id="limitations-of-network-policy_{context}"]
== Limitations of network policy

The following limitations apply to the use of network policy:

* You cannot use DNS names with network policy.
* You cannot use network policy with host network traffic. Pods with host networking enabled, such as in the following example, are unaffected by network policy rules.
+
[source,yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: host-net-pod
spec:
  hostNetwork: true
----

[id="types-of-network-traffic-supported_{context}"]
== Network traffic protocols supported

You can use specify a network policy for only the TCP, UDP, and SCTP network protocols.

[id="types-of-network-policy-rules_{context}"]
== Types of network policy rules

Network policy supports the following policy rules:

* Ingress
* Egress

A network policy can contain both ingress and egress network policy rules.

.Example network policy that uses both policy types
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: example-ingress-egress
spec:
  podSelector:
  policyTypes:
  - Ingress
  - Egress
----

Policy types are unidirectional. If you define both ingress and egress policies for your cluster, traffic must be allowed for both ingress and egress for network traffic between pods.

For example, if an ingress network policy rule allows a destination pod to receive traffic from a source pod, but the source pod is restricted from communicating with the destination pod with an egress network policy rule, the connection is blocked.

[NOTE]
====
If you are using the OpenShift SDN cluster network provider, only the ingress policy type is supported.
====

[id="policy-scope_{context}"]
== Network policy scope

A network policy is scoped to a specific namespace and can be further limited to a specific subset of pods in that namespace.

If multiple network policies are defined in a namespace they are applied additively, which means network policies can be created in any order.

[id="policy-isolation_{context}"]
== Network policy isolation of network traffic

A network policy can apply to the following network traffic flows:

* Traffic between pods in the same namespace
* Traffic between pods in different namespaces
* Traffic from an IP address block to a pod
* Traffic to an IP address block from a pod

[id="selectors_{context}"]
== Selectors

A network policy uses selectors in two ways:

* As an pod selector to select the pods that the policy isolates
* As a policy rule selector to select which traffic from a pod or to a pod to allow

[id="select-pods-that-a-policy-isolates_{context}"]
=== Selection of pods that a policy isolates

A pod selector identifies the set of pods that a network policy isolates. You can isolate all pods in a namespace or selectively apply a network policy to a subset of pods.

If you specify an empty `podSelector`, as in the following example, then all pods in a namespace are selected.

.Example network policy with an empty `podSelector` field
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: empty-pod-selector
spec:
  podSelector:
  ingress: []
  policyTypes:
  - Ingress
----

[id="select-pods-that-a-policy-rule-applies-to_{context}"]
=== Selection of pods that a policy rule applies to

When you specify a network policy rule, you use selectors to:

* Specify the namespaces that ingress and egress rules apply to
* Specify the pods in a selected namespace to apply to

The specific behavior for policy rule selectors is as follows:

* If only a namespace selector is used then a policy rule applies to all pods in that namespace.
* If only a pod selector is used then a policy rule applies to only the namespace in which the network policy is defined.
* If both a namespace selector and pod selector are used in a policy rule then only pods that satisfy both selectors are selected.

The following examples illustrate the rule selector behavior.

.Example network policy with a `namespaceSelector` field
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-namespace-selector
spec:
  podSelector:
  ingress:
  - namespaceSelector:
      matchLabels:
ifeval::[{product-version} < 4.8]
        networking/namespace: web
endif::[]
ifeval::[{product-version} >= 4.8]
        kubernetes.io/metadata.name: web
endif::[]
  policyTypes:
  - Ingress
----

.Example network policy with a `podSelector` field
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-pod-selector
spec:
  podSelector:
  ingress:
  - podSelector:
      matchLabels:
        deployment: blue
  policyTypes:
  - Ingress
----

.Example network policy with `namespaceSelector` and `podSelector` fields
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: ingress-combined-selector
spec:
  podSelector:
  ingress:
  - podSelector:
      matchLabels:
        deployment: blue
    namespaceSelector:
      matchLabels:
ifeval::[{product-version} < 4.8]
        namespace-name: web
endif::[]
ifeval::[{product-version} >= 4.8]
        kubernetes.io/metadata.name: web
endif::[]
  policyTypes:
  - Ingress
----

ifeval::[{product-version} < 4.8]
[NOTE]
====
A namespace does not have a label by default. To add a label to a namespace as a target for a namespace selector, add a label such as with the `oc label namespace <name> networking/namespace=<name>` command. Replace `<name>` with the name of the namespace the label is applied to.
====
endif::[]
ifeval::[{product-version} >= 4.8]
[NOTE]
====
Beginning with {product-title} 4.8, which is based on Kubernetes 1.21, the following label is added automatically to each namespace:

[source,yaml]
----
metadata:
  name: <name>
  labels:
    kubernetes.io/metadata.name: <name>
----
====
endif::[]

// Labels that a selector can target, not a selector itself.
[id="available-selector-policy-groups_{context}"]
=== Available labels for existing policy groups

Several custom labels are available in {product-title}:

`network.openshift.io/policy-group: ingress`::
+
--
Selects all Ingress Controller pods.

[NOTE]
====
If your `default` Ingress Controller runs on the host network, this namespace selector also allows all traffic for the host network. You can determine if your `default` Ingress Controller uses the `HostNetwork` endpoint publishing strategy with the following command:

[source,terminal]
----
$ oc get --namespace openshift-ingress-operator ingresscontrollers/default \
  --output jsonpath='{.status.endpointPublishingStrategy.type}'
----

If the previous command reports the endpoint publishing strategy as `HostNetwork`, then your `default` Ingress Controller is on the host network.
====
--

`policy-group.network.openshift.io/host-network`: ""::
Selects all host network traffic. You cannot combine this namespace selector with a pod selector.

[id="policy-rules_{context}"]
== Policy rules

A network policy must specify one or more policy rules that identifies what ingress or egress traffic is permitted for pods that the network policy isolates.

[id="policy-rule-logical-ordering_{context}"]
=== Logical ordering

In a single network policy one or more policy rules can be defined. The following logic applies when evaluating an array of one or more ingress or egress policy rules:

* If a policy rule includes both a namespace selector and a pod selector then a logical `and` is used when evaluating both.
* If multiple policy rules are defined then a logical `or` is used when evaluating each policy rule.

[id="policy-rule-precedence_{context}"]
=== Precedence

Any network policy rule that denies either ingress or egress traffic for a pod is always superseded by a policy rule that allows the denied traffic.

For example, consider the following network policies:

[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: web-deny-all
spec:
  podSelector:
    matchLabels:
      app: web
  ingress: []
---
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
metadata:
  name: web-allow-http
spec:
  podSelector:
    matchLabels:
      app: web
  ingress:
  - from:
    - podSelector: {}
    ports:
    - port: 8088
----

Because precedence indicates the rules that allow traffic always supersede rules that deny traffic, the effect of the two policies on the cluster is to allow ingress traffic only on port `8088` to the pod with the `app=web` label from any other pods in the same namespace. All other ingress traffic for the isolated pod is rejected.

[id="restrictions-by-ports-protocols_{context}"]
=== Restrictions by ports and protocols

You can restrict traffic by port and protocol. The following conditions apply:

- If you do not specify a port or a protocol, the policy rule applies to all traffic types on all ports
- If you specify a protocol but omit a port then the default is all ports
- If you specify a port but omit a protocol then the default protocol is TCP

When restricting pod traffic by port, the ports exposed by the containers within the pod through the `containers[].ports[].containerPort` field defines what ports are relevant.

.Example pod with a `containerPort` set
[source,yaml]
----
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-containerport
  spec:
    containers:
    - name: container-with-port
      ports:
      - containerPort: 8088
----

// This is alpha in 1.21
////
[NOTE]
====
Beginning with {product-title} n.m, which is based on Kubernetes 1.21, can specify range of ports.
====
////

[id="restrictions-by-ip_adress-blocks_{context}"]
=== Restrictions by IP address blocks

In addition to selectors for pods and namespaces, you can define a network policy rule that selects an IP address block specified in CIDR form. Optionally, you can exclude one or more subsets of the IP address block.

.Example ingress rule that matches an IP address block
[source,yaml]
----
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
metadata:
  name: <name>
spec:
  ingress:
  - from:
    - ipBlock:
        cidr: 172.17.0.0/16
        except:
        - 172.17.1.0/24
        - 172.17.2.0/24
----

In the previous example, the network policy allows ingress traffic from the `172.17.0.0/16` IP address block, except for traffic from the `172.17.1.0/24` and `172.17.2.0/24` IP address blocks.

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From:
      IPBlock:
        CIDR: 172.17.0.0/16
        Except: 172.17.1.0/24
  Not affecting egress traffic
  Policy Types: Ingress
////

[id="policy-rule-behavior-with-an-empty-selector_{context}"]
=== Behavior with an empty selector

If you specify an empty selector, the behavior of a network policy is as follows:

* For the pods selected by a network policy isolation selector:
 ** The policy applies to all pods in the namespace where the network policy is defined
* For the pods selected by a network policy rule selector:
 ** If a network policy ingress or egress rule specifies an empty namespace selector, the policy applies to all namespaces
 ** If a network policy ingress or egress rule specifies an empty pod selector, the policy applies to all pods in any selected namespace, or in all namespaces if no namespace selector is specified

////
TODO - why did I include this here?

[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: deny-all-ingress
spec:
  podSelector: {}
  ingress: []
---
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-all-https
spec:
  podSelector: {}
  ingress:
  - ports:
    - port: 443
---
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: allow-only-db-https
spec:
  podSelector: {}
  ingress:
    from:
    - namespaceSelector:
        matchLabels:
          app: db
      ports:
      - port: 443
----
////

[id="policy-rule-behavior-with-an-empty-ingress-or-egress-rule-set_{context}"]
=== Behavior with an empty ingress or egress rule set

If you define a network policy rule with an empty list, the network policy does not allow any traffic.

For example, the following ingress rule set selects no ingress traffic:

.Example ingress ruleset defined as an empty list
[source,yaml]
----
kind: NetworkPolicy
apiVersion: networking.k8s.io/v1
metadata:
  name: <name>
spec:
  ingress: []
----

////
Name:         name1
Namespace:    default
Created on:   2021-06-28 21:11:24 -0400 EDT
Labels:       <none>
Annotations:  <none>
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    <none> (Selected pods are isolated for ingress connectivity)
  Not affecting egress traffic
  Policy Types: Ingress
////

An empty rule set is the inverse of a rule set with a single empty selector, which selects which selects and allows all traffic. For example, the following ingress rule set selects all ingress traffic:

.Example ingress ruleset with a single empty selector
[source,yaml]
----
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
spec:
  ingress:
  - {}
----

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From: <any> (traffic not restricted by source)
  Not affecting egress traffic
  Policy Types: Ingress
////

The previous example is identical in behavior to the following example:

.Example ingress ruleset that matches all ingress traffic
[source,yaml]
----
kind: NetworkPolicy # Valid
apiVersion: networking.k8s.io/v1
spec:
  ingress:
  - from:
    - podSelector: {}
      namespaceSelector: {}
----

////
Spec:
  PodSelector:     <none> (Allowing the specific traffic to all pods in this namespace)
  Allowing ingress traffic:
    To Port: <any> (traffic allowed to all ports)
    From:
      NamespaceSelector: <none>
      PodSelector: <none>
  Not affecting egress traffic
  Policy Types: Ingress
////

[id="nework-policy-api_{context}"]
== Network policy API

When you specify network policy, you use the `NetworkPolicy` API in the `networking.k8s.io` API group.

//TODO: Various network policy API tables.

.`NetworkPolicy` object
[cols=".^2,.^2,.^6a",options="header"]
|====
|Field|Type|Description

|`metadata.name`
|`string`
|The name of the CNO object. This name is always `cluster`.

|`spec.egress`
|`object`
|

|`spec.ingress`
|`object`
|

|`spec.podSelector`
|`labelSelector`
|

|`spec.policyTypes`
|`array`
|Specifies the types of policies described by the object. Valid values for the array are `Egress` and `Ingress`. If not specified, the default is `["Egress"]`.

|====

.`spec.egress` object
[cols=".^2,.^2,.^6a",options="header"]
|====
|Field|Type|Description
|====

.`spec.ingress` object
[cols=".^2,.^2,.^6a",options="header"]
|====
|Field|Type|Description
|====

.`ports` array
[cols=".^2,.^2,.^6a",options="header"]
|====
|Field|Type|Description
|====

.`to` and `.from` objects
[cols=".^2,.^2,.^6a",options="header"]
|====
|Field|Type|Description
|====

//include::modules/nw-networkpolicy-about.adoc[leveloffset=+1]
//include::modules/nw-networkpolicy-optimize.adoc[leveloffset=+1]

[id="about-network-policy-next-steps"]
== Next steps

* xref:../../networking/network_policy/creating-network-policy.adoc#creating-network-policy[Creating a network policy]
* Optional: xref:../../networking/network_policy/default-network-policy.adoc#default-network-policy[Defining a default network policy]

[id="about-network-policy-additional-resources"]
== Additional resources

* xref:../../networking/network_policy/multitenant-network-policy.adoc#multitenant-network-policy[Configuring multitenant network policy]
* xref:../../rest_api/network_apis/networkpolicy-networking-k8s-io-v1.adoc#networkpolicy-networking-k8s-io-v1[NetworkPolicy API]
